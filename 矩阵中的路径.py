"""请设计一个函数,用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径,路径是可以从矩阵中的任意一个格子开始,每一步可以在矩阵中向左,向右,向上,向下移动一个格子.如果一条路径经过了矩阵中的某一个格子,则之后不能再次进入这个格子.列如a b c e s f c s a d c e 这样的3*4矩阵包含一条字符串的bcced的路径,但是矩阵中不包含'abcb'路径,因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后,路径不能再次进入该格子.a b c es f c sa d c e"""# 解题思路,回溯法import datetimeimport timedef time_(fun):    def warpper(*args,**kwargs):       start_time = time.time()       res = fun(*args,**kwargs)       end_time = time.time()       print((end_time-start_time))       return  res    return  warpper@time_class Solution:    def fun(self,arr,rows,cols,string_path):            if  len(arr) <= 0 or rows<1 or cols <1 or string_path == None :                return  False            visit_arr = [False] * (rows * cols)            # 行走的步数            path_step = 0            for row in range(rows):                for col in range(cols):                    # 满足则代表走通了                    if  self.haspath(arr,rows,cols,row,col,string_path,path_step,visit_arr):                              return  True            return  False    def haspath(self,arr,rows,cols,row,col,string_path,path_step,visit_arr):        if len(string_path) == path_step :            return  True        hasPath = False        # 条件是 行,列大于0,具体行,列位置坐标小于行列数,arr[row*cols+col]是具体位置的下标对应的值 要等于要找的字符串的值        #  并且visit_arr[位置]没走过        if row >=0 and row < rows and col >=0 and col < cols \            and  arr[row*cols+col] == string_path[path_step] and not visit_arr [row * cols + col]:            # 步数加1            path_step += 1            # 走完一个位置,改变位置状态,True表示走过了            visit_arr[row * cols + col] = True            # 代表上下左右            hasPath = self.haspath(arr,rows,cols,row,col-1,string_path,path_step,visit_arr) or \                      self.haspath(arr,rows,cols,row-1,col,string_path,path_step,visit_arr) or \                      self.haspath(arr,rows,cols,row,col+1,string_path,path_step,visit_arr) or \                      self.haspath(arr,rows,cols,row+1,col,string_path,path_step,visit_arr)            # 如果走不通,回溯,退到原来的位置            if not hasPath :                path_step -= 1                #并且改变原来位置的状态                visit_arr[row*cols + col] = False        return  hasPathprint(Solution().fun(list('abcesfcsadce'),3,4,list('ecd')))@time_class Solution1:    mask = []    def hasPath(self, matrix, rows, cols, path):        m_s = "".join(matrix)  # 将数组化为字符串，容易查找        count = m_s.count(path[0])  # 有几个可能的起点        t = 0        k = 0        if count == 0:            return False        else:            while k < count:                # 模板（判断是否重复）                mask = [[0] * cols for i in range(rows)]                index = m_s.find(path[0], t)                i = index // cols                j = index % cols                t = index + 1  # 控制下一个起点可能的搜索范围                k = k + 1                if self.define(matrix, rows, cols, i, j, path, mask):                    return True            return False    def define(self, matrix, rows, cols, i, j, path, mask):        if len(path) == 0:            return True        # 连通域判定条件        if i >= 0 and i <= rows - 1 and j >= 0 and j <= cols - 1 and matrix[i * cols + j] == path[0] and mask[i][j] != 1:            mask[i][j] = 1  # 表示已经过该节点            copy = path[1:]  # 将字符串向右移，则下次递归将判断下一个字符            # 递归，看下一个位置和下一个字符是否满足条件，只要有一个满足，则返回真            return self.define(matrix, rows, cols, i - 1, j, copy, mask) or \                   self.define(matrix, rows, cols, i + 1, j, copy, mask) or \                   self.define(matrix, rows, cols, i, j - 1, copy, mask) or \                   self.define(matrix, rows, cols, i, j + 1, copy, mask)        # 不满足连通域条件，返回false        return FalseS = Solution1()M = ["a", "b", "c", "e", "s", "f", "c", "s", "a", "d", "e", "e"]path = "bcced"print(S.hasPath(M, 3, 4, path))